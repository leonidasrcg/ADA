\documentclass[corference]{IEEEtran}
\usepackage[utf8]{inputenc} % Define la codificación del archivo
\usepackage{titling}
\usepackage{hyphenat} 
\usepackage[spanish]{babel}
% Usar Times New Roman con pdfLaTeX
\usepackage{mathptmx}
\usepackage{tocloft} % Para el índice
\usepackage{geometry}
\geometry{margin=1in,paperwidth=595pt,paperheight=841pt} % Márgenes seguros
% Paquetes adicionales
\usepackage{amsmath}
\usepackage{listings}
\usepackage{listingsutf8}
\usepackage{xcolor}
\usepackage{graphicx}
\usepackage{tikz}
\usepackage{setspace}
\usepackage{enumitem} 
\usepackage{ragged2e}

% Definición de colores para el código
\definecolor{codebg}{rgb}{0.95,0.95,0.95}      % Fondo gris claro
\definecolor{codeframe}{rgb}{0,0,0}      % Color del borde
\definecolor{keyword}{rgb}{0.13,0.55,0.13}     % Verde oscuro para palabras clave
\definecolor{comment}{rgb}{0.5,0.5,0.5}        % Gris para comentarios
\definecolor{string}{rgb}{0.58,0,0.83}         % Púrpura para cadenas
\definecolor{variable}{rgb}{0,0,1}             % Azul para variables
\definecolor{operator}{rgb}{0.75,0,0.75}       % Magenta para operadores

\lstdefinestyle{mystyle}{
    inputencoding=utf8,
    extendedchars=true,
    literate={ñ}{{\~n}}1
             {Ñ}{{\~N}}1
             {á}{{\'a}}1
             {é}{{\'e}}1
             {í}{{\'i}}1
             {ó}{{\'o}}1
             {ú}{{\'u}}1
             {Á}{{\'A}}1
             {É}{{\'E}}1
             {Í}{{\'I}}1
             {Ó}{{\'O}}1
             {Ú}{{\'U}}1,
    backgroundcolor=\color{codebg},         
    keywordstyle=\color{keyword}\bfseries, 
    commentstyle=\color{comment}\itshape,  
    stringstyle=\color{string},            
    identifierstyle=\color{variable},      
    basicstyle=\ttfamily\footnotesize,                           
    numbers=left,                          
    numberstyle=\tiny\color{codeframe},    
    frame=single,                          
    rulecolor=\color{codeframe},           
    captionpos=b,                          
    showstringspaces=false,                
    tabsize=4,                             
    xleftmargin=10pt,
    numbersep=5pt,
    breaklines=true,         
    postbreak=\mbox{\textcolor{red}{$\hookrightarrow$}\space},
}



% Documento
\begin{document}
\sloppy
\setlength{\columnsep}{16pt} % Modifica este valor para personalizar
\begin{titlepage}   
    % Apartado para configurar interlineado
    \setstretch{1.4} % Cambiar a 1, 1.25, 1.5, 2 para ajustar el interlineado
    
    % Inicio de la carátula
    \begin{center}
        \fontsize{12}{14}\selectfont % Tamaño 12 puntos con interlineado 14
        \textbf{“Año del Bicentenario, de la consolidación de nuestra Independencia, \\
        y de la conmemoración de las heroicas batallas de Junín y Ayacucho”}
        
        \includegraphics[width=0.4\textwidth]{LaSalle.jpg}\\
    
        
        \textbf{CARRERA: INGENIERÍA DE SOFTWARE} \\
        \textbf{PROYECTO FINAL} \\
        \textbf{ANALISIS Y DISEÑO E ALGORITMOS} \\
        
        \vspace{1cm}
        
        \textbf{ESTUDIANTES:} \\
        
        \vspace{1cm}
        
        \textbf{Carpio Guevara Rorigo Sebastian} \\
        \textbf{Flores Leon Miguel Angel} \\

        \vspace{1cm}
        
        \textbf{DOCENTE:} \\
        \textbf{Luque Mamani Edson Fracisco} \\

        \vspace{1cm}
        
        \textbf{Arequipa, Perú} \\
        \textbf{30 de noviembre de 2024}
    \end{center}
    \end{titlepage}
    % Fin de la carátula
    \newpage
    \newpage
    
    \renewcommand{\contentsname}{}
    
    \begin{center}
        \textbf{\huge Índice} % Título del índice centrado y en negrita
    \end{center}
    
    \tableofcontents
    
    \newpage
    \setlength{\parindent}{4em}
    \newpage
    \begin{flushleft}
    \begin{justify}
    
        \section{Introducción}
        \noindent\hspace*{4em}En este informe se presenta el desarrollo del proyecto final, el cual tiene el objetivo de analizar y visualizar la estructura de un grafo para una red social, esto con el proposito de descubrir patrones de interez y obtener informacion sobre la conectividad social, las estrcuturas de la comunidad y propiedades de la red.\\
    
        \noindent\hspace*{4em}Esta red social es conformada por dos bases de datos, una formada por diez millones de usuarios y la segunda esta formada por las ubicaciones de estos usuraios, Este conjunto de datos es un subconjunto de todos los usuarios de la red social, junto con sus conexiones y ubicaciones el grafo que crea el programa consiera a los usuarios como nodos y sus conexiones como aristas, por lo que forman un componente conectado del grafo total.\\
    
        \noindent\hspace*{4em}Para el analisis de los datos optamos por utilizar la libreria "polars" esto debido a la velocidad con la que trabaja y la eficiencia en el uso de los recursos, factores en los que supera a otras librerias como "pandas".\\
    
        \noindent\hspace*{4em}La construcción del grafo se logra cargandolo primero y luego almacenandolo en formato csv, luego el programa correra pruebas en el grafo y en los datos.\\
        
        \noindent\hspace*{4em}El de este programa es hacer un grafo realista y funcional de la red social con el objetivo de analizar a las distintas comunidades que esta posee y comprender como se relacionan, ademas de eso se evalua el uso de algoritmos para la carga y lectura e datos con el proposito de encontrar la opcion mas eficiente".\\
    
        \newpage
        
        \section{Uso de polars}
        \noindent\hspace*{4em}La libreria polars esta escrita en Rust, lo que lo hace mas eficiente a la hora de procesar grandes volumenes de datos a comparacion de las librerias basadas en NumPy, como caso de ejemplo si se ejecuta un groupby + sum() pandas tardaria un promedio de 31 segundos, mientras que polars tardaria un promedio de 4.5 segundos lo que representa una difencia de tiempo de un 85 porciento con respecto a pandas, esto debido a que polars ejecuta las operaciones en paralelo de manera automatica, dividendolas entre los nucleos del procesador .\\
        \noindent\hspace*{4em}Por lo tanto el uso utiliza esta libreria es la mejor opcion para la carga y el tratamiento de los grandes volumenes de datos requeridos.
        
        \section{Creacion del grafo}
        \noindent\hspace*{4em}El grafo se carga con los datos manejados con polars y la encargada de crear el grafo es la libreria Networkx, el programa carga las localizaciones en forma de latitud y longitud, luego se cargan los usuarios y se crean las aristas para finalizar con la medicion de tiempo, esto con el objetivo de saber cuanto tiempo le toma al programa crear el grafo, el uso de try es para hacer busqueda de exepciones dentro del la base de datos.\\
    \end{justify}
        
    
        \section{Explicación del Código }
            \subsection{Codigo}
            
            \begin{lstlisting}[language=python, style=mystyle, caption={Codigo para lectura de datos y carga del grafo}]
import igraph as ig
import time
import logging
import polars as pl
import pickle
import numpy as np

logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')

def crear_grafo_igraph(ubicaciones_path, usuarios_path, block_size=4_000_000):
    start_time = time.time()
    logging.info("Cargando ubicaciones...")

    ubicaciones = np.loadtxt(ubicaciones_path, delimiter=',')
    num_nodos = ubicaciones.shape[0]
    ubicaciones = [tuple(row) for row in ubicaciones]
    logging.info(f"Se cargaron {num_nodos} ubicaciones.")

    logging.info("Cargando usuarios y creando aristas (modo robusto y rápido)...")
    edges = []
    with open(usuarios_path, 'r', encoding='utf-8', errors='ignore') as file:
        block = []
        for line_number, line in enumerate(file, start=1):
            src = line_number - 1
            # Salta líneas vacías o con solo espacios
            if not line.strip():
                continue
            # Solo procesa si el nodo fuente es válido
            if not (0 <= src < num_nodos):
                continue
            conexiones = set()
            for x in line.split(','):
                x = x.strip()
                if not x.isdigit():
                    continue
                dst = int(x) - 1
                # Solo agrega si el destino es válido y no es un self-loop
                if 0 <= dst < num_nodos and dst != src:
                    conexiones.add(dst)
            block.extend((src, dst) for dst in conexiones)
            if (line_number) % block_size == 0:
                edges.extend(block)
                block = []
        if block:
            edges.extend(block)
    logging.info(f"Se procesaron {len(edges)} aristas.")

    g = ig.Graph(directed=True)
    g.add_vertices(num_nodos)
    g.add_edges(edges)
    g.vs["location"] = ubicaciones

    return g

def generar_tabla_grafos_ordenados(grafo, num_nodos=50):
    """
    Genera una tabla con información de los primeros y últimos nodos del grafo.
    """
    nodos = list(range(grafo.vcount()))
    primeros_nodos = nodos[:num_nodos]
    ultimos_nodos = nodos[-num_nodos:]
    nodos_seleccionados = primeros_nodos + ultimos_nodos

    data = []
    for idx, nodo in enumerate(nodos_seleccionados, start=1):
        loc = grafo.vs[nodo]["location"]
        if loc is not None:
            lat, lon = loc
        else:
            lat, lon = None, None
        conexiones = grafo.successors(nodo)
        num_conexiones = len(conexiones)
        print(f"Nodo {nodo+1}: Conexiones -> {[c+1 for c in conexiones]}")  # Mostrar base 1
        data.append({
            'Index': idx,
            'Nodo': nodo + 1,  # Mostrar base 1
            'Latitud': lat,
            'Longitud': lon,
            'Conexiones': num_conexiones
        })
    tabla = pl.DataFrame(data)
    return tabla
    

def realizar_eda(grafo):
    try:
        num_nodos = grafo.vcount()
        num_aristas = grafo.ecount()
        grados = grafo.degree()
        max_grado = max(grados)
        min_grado = min(grados)
        promedio_grado = sum(grados) / num_nodos

        logging.info(f"Número de nodos: {num_nodos}")
        logging.info(f"Número de aristas: {num_aristas}")
        logging.info(f"Grado máximo: {max_grado}")
        logging.info(f"Grado mínimo: {min_grado}")
        logging.info(f"Grado promedio: {promedio_grado:.2f}")
    except Exception as e:
        logging.error(f"Error durante el EDA: {e}")

# Define las rutas de los archivos de entrada y salida
ubicaciones_archivo = '10_million_location.txt'
usuarios_archivo = '10_million_user.txt'

# Crear el grafo
grafo = crear_grafo_igraph(ubicaciones_archivo, usuarios_archivo)

# Cargar el grafo desde el archivo guardado
if grafo:
    realizar_eda(grafo)
    tabla_grafos = generar_tabla_grafos_ordenados(grafo, num_nodos=50)
    print(tabla_grafos)
    tabla_grafos.write_csv('tabla_grafos.csv')
    print("Tabla guardada en 'tabla_grafos.csv'.")
            \end{lstlisting}
       
            \noindent\hspace*{4em}Este código es la carga de datos y la generacion el grafo dentro del programa como archivo de tipo csv.
         
    \includegraphics[width=0.5\textwidth]{Screenshot 28_04_2025 22_56_08.png}\\
    \caption{Imagen 1, prueba del funcionamiento del grafo}
    \label{fig:Screenshot 28_04_2025 22_56_08}
    \begin{justify}
    
        \section{Funcionamiento detallado del codigo}
        \noindent\hspace*{4em}Primero se importan las librerias, se usa igraph para trabajar con los grafos, loggin para registrar la informacion de la ejecucion, polars para el tratamiento de grandes volumenes de datos y time que es el modulo para medir el tiempo , luego se inicia el contador, despues se lee el archivo e ubicaciones y se renombran las columnas a lat y log, el programa recorre el archivo de ubicaciones cada fila se convierte en un nodo con el atributo location para cargar el grafo, se abre el archivo de ususarios y se lee linea por linea ajustando el valor, se añade una arista desde el nodo line number +1 a cada nodo j, luego se muestra el tiempo total de ejecucion y se almacena el grafo como un archivo csv.\\
        
        \noindent\hspace*{4em}Luego se abre el archivo csv y se carga.\\
    \end{justify}    
    
\end{document}
